package main

import (
	"fmt"
	"sync"
)

/*
sync.once
内部其实是一个懒汉式的有这双重校验的单例模式
其维护一个boolean变量和一个mutex，执行do方法的时候接收初始化函数作为其参数
Boolean如果为true表示这个初始化函数执行过，直接返回，如果为false，则用mutex上锁，执行初始化函数
*/

var onceLock sync.Once
var bodys map[string]string

func main() {

	fmt.Println(doOnce())

}

func doOnce() map[string]string {
	//传递的参数为初始化函数，并且这个初始化函数不需要我们做额外的处理
	onceLock.Do(initMaps)
	return bodys
}

func initMaps() {
	bodys = make(map[string]string, 4)
	bodys["aa"] = "a"
	bodys["bb"] = "b"
	bodys["cc"] = "c"
	bodys["dd"] = "d"
}

/*
go自带的竞争条件检测工具
在go build，go run或者go test命令后面加上-race
编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，
并且会记录下每一个读或者写共享变量的goroutine的身份信息。
另外，修改版的程序会记录下所有的同步事件，比如go语句，channel操作，以及对(*sync.Mutex).Lock，(*sync.WaitGroup).Wait等等的调用
这个工具会打印一份报告，内容包含变量身份，读取和写入的goroutine中活跃的函数的调用栈。这些信息在定位问题时通常很有用
它只能检测到运行时的竞争条件；并不能证明之后不会发生数据竞争
由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存
*/

/*
总结一下go的协程和Java的线程有什么差距
第一就是协程使用的是动态栈，他用于保存数据的栈空间是动态的，不像线程一样是定死的2mb或者1mb，协程最小可以达到2kb，最大可以1g
这就使空间利用率提高了不少，所以可以支持大量的协程同时出现，协程很轻量还有一个原因就是他不需要记录很多对他没有用处的信息
比如线程需要记录一些列信息，比如自己的id，自己要是哪个进程的id等等，协程什么id都没有，就记录自己要执行的逻辑

第二就是他的调度室有go的中央调度器进行调度，和操作系统的线程调度不同的是，
Go调度器并不是用一个硬件定时器，而是被Go语言本身进行调度的。
例如当一个goroutine调用了time.Sleep，或者被channel调用或者mutex操作阻塞时，
调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。
因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。
因为操作系统的调度都是源于中断，而一个中断就需要处理中断指令这都是写额外的操作，go是发现你要阻塞主动换一个执行，是主动式的
最主要还是因为没有上下文切换，还有就是go的调度只用关心自己的协程，不像操作系统的调度还得关心其他线程一起参与调度

第三就是go他是一个m:n的形式进行调度的，而m就是我们再代码中创建的线程数目，而n就是GOMAXPROCS
Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行Go的代码。
其默认的值是运行机器上的CPU的核心数，所以在一个有8个核心的机器上时，调度器一次会在8个OS线程上去调度GO代码
可以用GOMAXPROCS的环境变量来显式地控制这个参数，或者也可以在运行时用runtime.GOMAXPROCS函数来修改它

*/

/*
这句话特别好
使用包的封装性
可以保证内部变量的一致性和并发时的互斥约束。
*/

/*
go的编译为啥那么快
Go语言的闪电般的编译速度主要得益于三个语言特性。
第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。
第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。
第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。
因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件
（译注：很多都是重复的间接依赖）。
*/

/*
导入一个匿名的包，这个包虽然没有显性的被使用，但是他还是会被编译到，而其有时候也会有作用，主要用来替换一些原本的包
比如数据库包database/sql也是采用了类似的技术，让用户可以根据自己需要选择导入必要的数据库驱动。
*/

/*
src用于保存源文件，pkg用于保存编译后的文件，bin用于保存可执行文件
*/

/*
go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，
生成一个临时的main包用于调用相应的测试函数，接着构建并运行、报告测试结果，最后清理测试中生成的临时文件。
*/

/*
测试方法中的参数必须为(t *testing.T) t参数用于报告测试失败和附加的日志信息
*/
